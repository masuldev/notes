# 피닉스 서버

## Snowflakes Server (스노우 플레이크 서버)
예전에 일반적으로 서버를 운영하는 방법은 서버를 설치한 후 OS를 인스톨한 후에, 필요한 소프트웨어와 애플리케이션을 설치하여 운영하는 형태였다.  
여기에 문제가 생긴 경우 패치를 하거나 정기적인 보안 패치 튜닝들을 해당 서버에 지속적으로 적용하고, 애플리케이션은 CI/CD 등의 툴을 이용하여 배포하는 구조를 가지고 있었다.

이렇게 한번 설치한 서버에 계속해서 설정을 변경하고 패치를 적용하는 등의 업데이트를 지속적으로 적용하여 운영하는 서버를 스노우 플레이크 서버라고 하는데,  
이렇게 설정된 서버는 다시 똑같이 설정하기가 매우 어렵다.  
모든 설정과정이 무넛화가 잘되어 있으면 모르겠지만 대부분 문서화가 꼼꼼한 경우도 드물뿐더러, 담당자가 바뀌거나 관리 조직이 바뀌는 경우에는 그 이력이 제대로 유지되는 경우가 없다.  
그래서 장비를 업그레이드 하거나 OS를 새로 인스톨해서 같은 환경을 꾸미고자 할 때 예전 환경과 동일한 환경을 구성하기가 어렵기 때문에 누락된 설정이나 패치등에 의해서 장애가 발생하는 경우가 많다.  
이렇게 한번 설정을 하고 다시 설정이 불가능한, **"마치 눈처럼 녹아버리는"** 서버의 형태를 스노우 플레이크 서버라고 한다.

재구성의 문제뿐 아니라 이런 스노우 플레이크 서버는 구성 편차를 유발하기도 하는데, 여러대의 웹서버를 운영하고 있는 조직에서 특정 서버에서 문제가 발생하여 패치를 한 경우,
다른 웹서버를 모두 패치하지 않는 이상 구성이 달라진다. 이는 운영상의 문제를 일으킬 수 있다.

## Phoenix Server (피닉스 서버)
그래서 나온 서버 패턴이 피닉스 서버 패턴인데, 피닉스(불사조)는 불멸로도 알려져 있지만 정확히는 불속에서 다시 태어나는 re-born(재탄생)의 개념을 가지고 있다.  
이 재탄생의 개념을 서버 설정 방식에 적용한 패턴이 피닉스 서버 패턴이다.  
새로운 소프트웨어를 인스톨하거나 설정을 변경할 때 기존 서버에 변경 작업을 하는 것이 아니라, 처음 OS 설치에서부터, 소프트웨어 인스톨, 설정 변경까지를 다시 반복하는 것이다.
예를 들어 우분투 16, 톰캣 7.0 버전으로 운영되는 서버에서 fluentd를 로그 수집 모듈로 설치하는 케이스가 있다고 가정하자.

스노우 플레이크 서버 패턴의 경우에는 이미 운영되고 있는 서버에 새롭게 fluentd를 일일이 설치하거나 자동화가 되어있는 경우에는 ansible이나 chef등의 configuration management 도구를 이용하여 설치하게 된다.

피닉스 서버 패턴의 경우에는 새 VM을 다시 만들고, 우분투 16 OS를 설치하고, 톰캣 7.0을 설치하고 fluentd를 설치한 다음, 이 VM으로 기존 VM을 교체한다.

매번 전체 설치를 반복한다면 매우 많은 시간이 드는 문제가 있다.  
해당 문제는 매번 새롭게 모든 스택을 설치하지 않는다는 것으로 해소가 가능하다.  
어느정도 공통 스택은 가상머신의 베이스 이미지 (VM Base Image)로 만들어 놓고, 이 이미지를 이용하여 VM을 생성한 후에, 차이가 나는 부분만 설정을 구조를 사용하게 되고,  
이 과정은 스크립트 코드를 이용해서 자동화하기 때문에, 시간 단축이 가능하다.  
피닉스 서버 패턴에서는 스크립트를 이용해서 셋팅을 하기 때문에, 다음과 같은 장점을 가지게 된다.

* 스크립트에 모든 설정 정보가 유지된다.
* 스크립트 코드를 git과 같은 소스 코드 관리 시스템을 이용하여 관리하게 되면, 어떤 부분을 누가 어떻게 수정했는지 추적이 가능하다.

